package com.farmerworking.db.rabbitDb.impl;

import com.farmerworking.db.rabbitDb.api.FilterPolicy;
import com.farmerworking.db.rabbitDb.impl.utils.Hash;

import java.util.Arrays;
import java.util.List;

public class BloomFilterPolicy implements FilterPolicy {
    private final int bitsPerKey;
    private int k;

    public BloomFilterPolicy(int bitsPerKey) {
        this.bitsPerKey = bitsPerKey;

        // We intentionally round down to reduce probing cost a little bit
        this.k = (int)(bitsPerKey * 0.69);  // 0.69 =~ ln(2)
        if (k < 1) {
            k = 1;
        }

        if (k > 30) {
            k = 30;
        }
    }

    public String createFilter(List<String> keys) {
        int bits = bitsPerKey * keys.size();

        // For small n, we can see a very high false positive rate.  Fix it
        // by enforcing a minimum bloom filter length.
        if (bits < 64) {
            bits = 64;
        }

        int bytes = (bits + 7) / 8;
        bits = bytes * 8;

        char[] array = new char[bytes];
        Arrays.fill(array, (char)0);

        for(String key : keys) {
            int hash = Hash.bloomHash(key);
            int delta = computeDelta(hash);

            for (int i = 0; i < this.k; i++) {
                int pos = Integer.remainderUnsigned(hash, bits);
                array[pos / 8] |= (1 << (pos % 8));
                hash += delta;
            }
        }

        return String.valueOf(array) + (char) this.k;
    }

    @Override
    public boolean keyMayMatch(String key, String filter) {
        if (filter.length() < 2) {
            return false;
        }

        int bits = (filter.length() - 1) * 8;
        char[] data = filter.toCharArray();

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters
        int encodingK = (int)data[data.length - 1];
        if (encodingK > 30) {
            // Reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            return true;
        }

        int hash = Hash.bloomHash(key);
        int delta = computeDelta(hash);

        for (int i = 0; i < k; i++) {
            int pos = Integer.remainderUnsigned(hash, bits);

            if ((data[pos/8] & (1 << (pos % 8))) == 0) {
                return false;
            }
            hash += delta;
        }

        return true;
    }

    @Override
    public String name() {
        return "leveldb.BuiltinBloomFilter2";
    }

    private int computeDelta(int hash) {
        return (hash >>> 17) | (hash << 15);
    }
}
